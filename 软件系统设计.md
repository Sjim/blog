# 软件系统设计

## 软件设计原则

##### 单一职责原则

- 一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中
- 类承担的指责越多，被复用的可能性越小
- 两方面职责：数据职责和行为职责 数据职责：属性  行为职责： 方法
- 高内聚低耦合
- 需要设计人员发现不同的职责并分离

##### 开闭原则

- 软件实体应当对扩展开放，对修改关闭 —— 不允许修改 允许在不被修改的前提下被扩展
- 抽象化 是关键
- 对可变封装性原则  应对软件需求的增加和改变通过替换原有的模块 即将原有的模块封装

##### 里氏代换原则

- 所有引用父类的地方必须能**透明地使用其子类对象**  即子类能等效的使用父类中的所有方法 即不能重写父类的方法 （所以保证了鲁棒性  可以在增加继承之后不会影响原来代码的使用
- 可以添加独有的方法
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

##### 依赖倒转原则

- 高层模块不应该依赖于底层模块，都应该依赖抽象；抽象不依赖于细节，细节依赖于抽象
- 面向接口编程
  - 每个类提供接口或抽象类
  - 变量的声明尽量是接口或抽象类
  - 类不应该从具体类派生
  - 使用里氏替换原则

##### 接口隔离原则

- 客户端不应该依赖它不需要的接口
- 一旦接口太大需要将他分割成更细小的接口
  - 使用多个专门的接口而不是一个总接口
  - 拆分接口时满足单一职责原则同时满足高内聚

##### 合成复用原则

- 尽量使用对象组合而不是继承来达到复用的目的
  - 继承
    - 子类知道父类的细节 这不好
    - 子类受父类变化的影响 不利于扩展和维护
    - 限制了复用的灵活性
- 必须使用里氏替换原则
- 组合依赖强 被组合对象数量少 生命直接相关  车和轮胎 不同；聚合关系弱 数组链表 类型往往相同 
- 最好使用关联关系使用已有对象

##### 迪米特原则

- 最少知识原则
  - 不要和陌生人说话
  - 只于你的直接朋友通信
    - 迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
- 两个类之间不必彼此直接通信 就不应当发生直接的相互作用——可以通过第三者转发这个调用
- 狭义的迪米特法则：降低类之间的耦合 但会造成系统的不同模块之间的通信效率降低
- 广义：对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制
- 降低变量访问权限 尽量设计成不变类 

![image-20210625215326932](C:\Users\Administrator.DESKTOP-CGIO78B\AppData\Roaming\Typora\typora-user-images\image-20210625215326932.png)

### 设计原则

- 封装变化

![image-20210626163757691](C:\Users\Administrator.DESKTOP-CGIO78B\AppData\Roaming\Typora\typora-user-images\image-20210626163757691.png)

### 设计模式

https://zhuanlan.zhihu.com/p/345126462

http://c.biancheng.net/view/1320.html.

1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。
2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。

#### 创建型模式

创建型模式分为以下几种。

- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。



- 单例模式 singleton
  - 指一个类只有一个实例，且该类能自行创建这个实例的一种模式
    - 单例类只有一个实例对象；
    - 该单例对象必须由单例类自行创建；
    - 单例类对外提供一个访问该单例的全局访问点。
  - 单例模式的优点：
    - 单例模式可以保证内存里只有一个实例，减少了内存的开销。
    - 可以避免对资源的多重占用。
    - 单例模式设置全局访问点，可以优化和共享资源的访问。
  - 单例模式的缺点：
    - 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。
    - 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。
    - 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。
  - ![单例模式的结构图](http://c.biancheng.net/uploads/allimg/181113/3-1Q1131K441K2.gif)
- 原型模式prototype 
  - 原型模式复制一个对象自身，克隆出多个对象。 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象（高效 无需知道对象创建细节
    - 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
    - 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。
  - 原型模式实现了一个原型接口，该接口用于创建该对象的克隆。 当直接创建对象代价比较大时，可以用原型模式
    - 对象之间相同或相似，即只是个别的几个属性不同的时候。
    - 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
    - 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
    - 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。
    - 辅助实现撤销操作 恢复到历史的某一状态
  - 优点
    - 简化创建对象流程
  - 缺点：
    - 需要为每一个类配备一个 clone 方法，实现深克隆时需要编写比较复杂的代码 
    - 违反开闭原则
  - ![原型模式的结构图](http://c.biancheng.net/uploads/allimg/181114/3-1Q114101Fa22.gif)
- 简单工厂模式

  - 静态工厂方法 创建实例的方法多为静态方法
  - 类创建型模式
  - 创建的产品不多 只需要一个工厂类就能完成
  - 缺点：
    - 集中了所有产品创建逻辑 职责过重 一旦宕机所有都不能用
    - 增加类的个数，增加复杂度和理解难度 扩展更加复杂
    - 简单工厂使用静态工厂方法 工厂角色无法形成基于继承的等级结构
    - 不符合开闭原则
  - 适用情况：
    - 负责创建对象比较少
    - 客户端只知道工厂类的参数 不关心方法
  - 创建和使用分离 解耦
  - ![简单工厂模式的结构图](http://c.biancheng.net/uploads/allimg/200908/5-200ZQ64244445.png)
- 工厂方法模式 
  - 工厂父类负责定义创建产品 对象的公共接口，而工厂子类则负责生成具体的产品对 象，这样做的目的是将产品类的实例化操作延迟到工厂 子类中完成，即通过工厂子类来确定究竟应该实例化哪 一个具体产品类。 只解决一类产品的不同品牌
  - 解决开闭原则
  - 优点：
    - 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
    - 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
    - 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。
  - 缺点：
    - 设计复杂
    - 增加了系统的抽象性和理解难度
    - 添加新产品类，需要提供与之对应的具体工厂类 成对增加
  - 场景
    - 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。
    - 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
    - 客户不关心创建产品的细节，只关心产品的品牌
  - ![工厂方法模式的结构图](http://c.biancheng.net/uploads/allimg/181114/3-1Q114135A2M3.gif)
- 抽象工厂模式 abstract factory
  - 工厂方法+约束
  - 抽象工厂中有多个工厂方法 
  - 提供一个创 建一系列相关或相互依赖对象的接口，而无须指定它们 具体的类。抽象工厂模式又称为Kit模式，属于对象创建 型模式。
  - 当系统所提供的工厂所需生产的具体产品并不是一个简单的 对象，而是多个位于不同产品等级结构中属于不同类型的具体 产品时需要使用抽象工厂模式。颜色+品牌+品种
  - 工厂方法模 式针对的是一个产品等级结构，而抽象工厂模式则需要面对多 个产品等级结构
  - 优点：
    - 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
    - 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
    - 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。
  - ![抽象工厂模式的结构图](http://c.biancheng.net/uploads/allimg/181114/3-1Q11416002NW.gif)
- 建造者模式 builder
  - 指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的[设计模式](http://c.biancheng.net/design_pattern/)被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。
  - 将部件和其组装过程分开，一步一步创建一个复杂对象
  - 优点如下：
    1. 封装性好，构建和表示分离。
    2. 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
    3. 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。
  - 缺点如下：
    1. 产品的组成部分必须相同，这限制了其使用范围。
    2. 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。
  - 通过前面的学习，我们已经了解了建造者模式，那么它和工厂模式有什么区别呢？
    - 建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。
    - 创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样
    - 关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。
    - 建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。
  - ![建造者模式的结构图](http://c.biancheng.net/uploads/allimg/181114/3-1Q1141H441X4.gif)

#### 结构型模式

- 代理模式 proxy

  - 客户不想或不能直接引用一个对象 使用代理来间接引用
  - 对象结构型模式
  - 代理模式的主要优点有：
    - 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
    - 代理对象可以扩展目标对象的功能；
    - 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性
    - 目标类和适配者类解耦
    - 增加类的透明性和复用性
    - 灵活性扩展性好
  - 其主要缺点是：
    - 代理模式会造成系统设计中类的数量增加
    - 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
    - 增加了系统的复杂度；
    - 解决方法：动态代理
  - ![代理模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q115093011523.gif)

- 适配器模式 adapter

  - 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作

  - 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

  - 该模式的主要优点如下。

    - 客户端通过适配器可以透明地调用目标接口。
    - 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
    - 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
    - 在很多业务场景中符合开闭原则。
    - 目标类和适配者类解耦
    - 增加类的透明性和复用性
    - 灵活性扩展性好

  - 其缺点是：

    - 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。
    - 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。

  - 实现

    - 类适配： java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。
    - 对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。

  - 双向适配器：

    - 适配器中同时包含对目标类和适配这类的引用，适配这类可以通过调用目标类中的方法
    - 目标类可以通过它调用适配者类中的方法

  - ![类适配器模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151045351c.gif)

    ![对象适配器模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151046105A.gif)

- 桥接模式 bridge

  - 将抽象与实现分离，使它们可以独立变化。
  - 它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
  - 遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放
  - 桥接（Bridge）模式的优点是：
    - 抽象与实现分离，扩展能力强
    - 符合开闭原则
    - 符合合成复用原则
    - 其实现细节对客户透明
  - 缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。
  - 桥接模式和适配器模式用于设计的不同阶段，桥接模式 用于系统的初步设计，对于存在两个独立变化维度的类 可以将其分为抽象化和实现化两个角色，使它们可以分 别进行变化；而在初步设计完成之后，当发现系统与已 有类无法协同工作时，可以采用适配器模式。但有时候 在设计初期也需要考虑适配器模式，特别是那些涉及到 大量第三方应用接口的情况。
  - 桥接（Bridge）模式包含以下主要角色。
    1. 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
    2. 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
    3. 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
    4. 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。
  - ![桥接模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q115125253H1.gif)

- 装饰模式

  - 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。
  - 对客户透明的方式动态地给一个对象附加 上更多的责任
  - 装饰器模式的主要优点有：
    - 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
    - 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果
    - 装饰器模式完全遵守开闭原则
  - 缺点
    - 很难限制装饰增加的类型 （需要条件判断
    - 大对象分解为许多小对象 删除装饰较困难
    - 装饰器模式会增加许多子类，过度使用会增加程序得复杂性。
  - ![装饰模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q115142115M2.gif)

- 外观模式 facade 
  - 对象结构型模式
  - 用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现 从而**降低系统耦合度**
  - 与子系统的通信通过一个统一的外观对象，为系统中的一组接口提供一个一致的界面 使得子系统更易使用(简化接口)更好的边界 
  - 体现
    - 单一职责原则 子系统之间的通信和相互依赖关系达到最小
    - 迪米特法则：降低客户类与子系统类的耦合性
    - 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
    - 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
    - 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。
  - 缺点：
    - 不能很好的限制客户使用子系统类
    - 新增子系统可能需要修改外观类或客户端的源代码 违背开闭原则(引入抽象外观类)
  - 适用：
    - 复杂子系统提供简单接口
    - 客户程序对多个子系统之间存在很大依赖性
  - 扩展
    - 系统可能有多个外观类  每个外观类只有一个实例 常与**单例模式结合**
    - 不通过继承外观类在子系统中加入新的行为
    - 当增加新的子系统或者一处子系统时需要修改外观类，可以通过引入抽象外观类在一定程度解决问题，客户针对抽象外观类进行编程
  - ![外观模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q115152143509.gif)
- 享元模式
  - 对象数量太多 导致运行代价过高 通过共享技术实现相同或相似的对象的重用
  - 可以共享的内容成为内部状态 需要外部环境来设置的不能共享的内容成为外部状态
  - 享元对象设置为较小的对象 通过共享技术来实现大量细粒度对象的复用
  - 其主要缺点是：
    1. 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。
    2. 读取享元模式的外部状态会使得运行时间稍微变长。
  - 状态
    - 内部状态指对象共享出来的信息，存储在享元信息内部，并且不回随环境的改变而改变；
    - 外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享
  - ![享元模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q115161342242.gif)
- 组合模式composite pattern
  - 有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性，属于结构型[设计模式](http://c.biancheng.net/design_pattern/)。
  - 组合模式的主要优点有：
    1. 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；
    2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；
  - 其主要缺点是：
    1. 设计较复杂，客户端需要花更多时间理清类之间的层次关系；
    2. 不容易限制容器中的构件；
    3. 不容易用继承的方法来增加构件的新功能；
  - 如何将容器对象和叶子对象进行递归组合
  - 用户使用时无需区分  可以一致的对待
  - ![透明式的组合模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151G62L17.gif)
  - ![安全式的组合模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151GF5221.gif)

#### 行为性模式

- 模板方法模式

  - 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。
  - 基本方法是实现算法的各个方法
  - 该模式的主要优点如下。
    1. 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
    2. 它在父类中提取了公共的部分代码，便于代码复用。
    3. 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。
  - 该模式的主要缺点如下。
    1. 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。
    2. 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
    3. 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。
  - ![模板方法模式的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q116095405308.gif)
- 策略模式（strategy policy
  - 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。
  - 定义算法族，实现同一个策略接口
  - 实现类的细节暴露给用户
  - 使得算法与用户的客户端独立
  - 解决多态  多个if else
  - 其主要缺点如下。
    1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
    2. 策略模式造成很多的策略类，增加维护难度。
  - 使用情况：
    - 不同的行为 返回值不同
    - 不同的算法 返回值相同 不同trade off
  - 后果
    - 对客户不透明 客户需要了解不同实现的细节
    - 增加的对象的数量
  - 优点
    - 子类替代品
  - 怎么使用
    - 框架 主要研究问题
  - ![策略模式的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q116103K1205.gif)
- 命令模式 command
  - 方法的请求者与实现者解耦
  - 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。
  - 命令模式的主要优点如下。
    1. 通过引入中间件（抽象接口）降低系统的耦合度。
    2. 扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。
    3. 可以实现宏命令。命令模式可以与[组合模式](http://c.biancheng.net/view/1373.html)结合，将多个命令装配成一个组合命令，即宏命令。
    4. 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的[备忘录模式](http://c.biancheng.net/view/1400.html)结合，实现命令的撤销与恢复。
    5. 可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。
  - 其缺点是：
    1. 可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。
    2. 命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是[设计模式](http://c.biancheng.net/design_pattern/)的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。
  - ![命令模式的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q11611335E44.gif)
  - ![组合命令模式的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q1161135322R.gif)
- 责任链模式 chain of responsibility
  - 为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
  - 在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。
  - 责任链模式是一种对象行为型模式，其主要优点如下。
    1. 降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
    2. 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
    3. 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
    4. 责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
    5. 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。
  - 其主要缺点如下。
    1. 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
    2. 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
    3. 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。
  - ![责任链模式的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q116135Z11C.gif)

- 状态模式
  - 行为取决于一个或多个动态变化的属性，引入抽象类表示对象的状态
  - 对象的行为不是固定的，根据对象所处的状态，会有行为的变化。我们要求有一种属性（心情），这个属性会影响对象的行为（高兴时怎么做，难过时怎么做）
  - 状态模式：允许一个对象在状态改变时，改变它的行为。对象看起来似乎是改变了它的行为。状态对用户而言是隐藏的（透明的）。
  - 状态模式是一种对象行为型模式，其主要优点如下。
    1. 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。
    2. 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
    3. 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。
  - 状态模式的主要缺点如下。
    1. 状态模式的使用必然会增加系统的类与对象的个数。
    2. 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。
    3. 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。
  - ![状态模式的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q11615412U55.gif)
  
- 观察者模式 observer

  - 指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。
  - 发布订阅 模型视图 从属者
  - 对象行为型模式
  - 观察者模式是一种对象行为型模式，其主要优点如下。
    1. 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。
    2. 目标与观察者之间建立了一套触发机制。
  - 缺点
    - 通知观察者时间长4
    - 观察者和观察目标之间有循环依赖  导致系统崩溃
    - 不知道确切的变化 
    - 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。
  - ![观察者模式的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q1161A6221S.gif)

- 中介模式 mediator

  - 定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。
  - 中介者模式是一种对象行为型模式，其主要优点如下。
    1. 类之间各司其职，符合迪米特法则。
    2. 降低了对象之间的耦合性，使得对象易于独立地被复用。
    3. 将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。
  - 其主要缺点是：中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。
  - ![中介者模式的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q1161I532V0.gif)

- 迭代器模式

  - 既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：
    1. 暴露了聚合类的内部表示，使其数据不安全；
    2. 增加了客户的负担。
  - “迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”
  - 提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
  - 迭代器模式是一种对象行为型模式，其主要优点如下。
    1. 访问一个聚合对象的内容而无须暴露它的内部表示。
    2. 遍历任务交由迭代器完成，这简化了聚合类。
    3. 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。
    4. 增加新的聚合类和迭代器类都很方便，无须修改原有代码。
    5. 封装性良好，为遍历不同的聚合结构提供一个统一的接口。
  - 其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。
  - ![迭代器模式的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q1161PU9528.gif)

- 访问者模式 visitor

  - 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。

  - 当系统中存在类型数量稳定（固定）的一类数据结构时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。

    **简而言之，就是当对集合中的不同类型数据（类型数量稳定）进行多种操作时，使用访问者模式。**

  - 访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。

    1. 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
    2. 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
    3. 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
    4. 符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。

  - 访问者（Visitor）模式的主要缺点如下。

    1. 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
    2. 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
    3. 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。

  - (1)与“[迭代器模式](http://c.biancheng.net/view/1395.html)”联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。如【例1】中的对象结构是用 List 实现的，它通过 List 对象的 Iterator() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。

    (2)访问者（Visitor）模式同“[组合模式](http://c.biancheng.net/view/1373.html)”联用。因为访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到[组合模式](http://c.biancheng.net/view/1373.html)，其结构图如图 4 所示。

  - ![访问者（Visitor）模式的结构图](http://c.biancheng.net/uploads/allimg/181119/3-1Q11910135Y25.gif)

- 备忘录模式 memento

  - 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。
  - 备忘录模式是一种对象行为型模式，其主要优点如下。
    - 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
    - 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
    - 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。
  - 其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。
  - ![备忘录模式的结构图](http://c.biancheng.net/uploads/allimg/181119/3-1Q119130413927.gif)

- 解释器模式 interpretor

  - 给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。
  - 解释器模式是一种类行为型模式，其主要优点如下。
    1. 扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
    2. 容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。
  - 解释器模式的主要缺点如下。
    1. 执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。
    2. 会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。
    3. 可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。

### 设计模式实例

| 分类                                          | 设计模式                                                     | 简述                                                       | 一句话归纳                     | 目的         | 生活案例       |
| --------------------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------------- | ------------------------------ | ------------ | -------------- |
| 创建型设计模式 （简单来说就是用来创建对象的） | 工厂模式（Factory Pattern）                                  | 不同条件下创建不同实例                                     | 产品标准化，生产更高效         | 封装创建细节 | 实体工厂       |
| 单例模式（Singleton Pattern）                 | 保证一个类仅有一个实例，并且提供一个全局访问点               | 世上只有一个我                                             | 保证独一无二                   | CEO          |                |
| 原型模式（Prototype Pattern）                 | 通过拷贝原型创建新的对象                                     | 拔一根猴毛，吹出千万个                                     | 高效创建对象                   | 克隆         |                |
| 建造者模式（Builder Pattern）                 | 用来创建复杂的复合对象                                       | 高配中配和低配，想选哪配就哪配                             | 开放个性配置步骤               | 选配         |                |
| 结构型设计模式 （关注类和对象的组合）         | 代理模式（Proxy Pattern）                                    | 为其他对象提供一种代理以控制对这个对象的访问               | 没有资源没时间，得找别人来帮忙 | 增强职责     | 媒婆           |
| 外观模式（Facade Pattern）                    | 对外提供一个统一的接口用来访问子系统                         | 打开一扇门，通向全世界                                     | 统一访问入口                   | 前台         |                |
| 装饰器模式（Decorator Pattern）               | 为对象添加新功能                                             | 他大舅他二舅都是他舅                                       | 灵活扩展、同宗同源             | 煎饼         |                |
| 享元模式（Flyweight Pattern）                 | 使用对象池来减少重复对象的创建                               | 优化资源配置，减少重复浪费                                 | 共享资源池                     | 全国社保联网 |                |
| 组合模式（Composite Pattern）                 | 将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理 | 人在一起叫团伙，心在一起叫团队                             | 统一整体和个体                 | 组织架构树   |                |
| 适配器模式（Adapter Pattern）                 | 将原来不兼容的两个类融合在一起                               | 万能充电器                                                 | 兼容转换                       | 电源适配     |                |
| 桥接模式（Bridge Pattern）                    | 将两个能够独立变化的部分分离开来                             | 约定优于配置                                               | 不允许用继承                   | 桥           |                |
| 行为型设计模式 （关注对象之间的通信）         | 模板模式（Template Pattern）                                 | 定义一套流程模板，根据需要实现模板中的操作                 | 流程全部标准化，需要微调请覆盖 | 逻辑复用     | 把大象装进冰箱 |
| 策略模式（Strategy Pattern）                  | 封装不同的算法，算法之间能互相替换                           | 条条大道通罗马，具体哪条你来定                             | 把选择权交给用户               | 选择支付方式 |                |
| 责任链模式（Chain of Responsibility Pattern） | 拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 | 各人自扫门前雪，莫管他们瓦上霜                             | 解耦处理逻辑                   | 踢皮球       |                |
| 迭代器模式（Iterator Pattern）                | 提供一种方法顺序访问一个聚合对象中的各个元素                 | 流水线上坐一天，每个包裹扫一遍                             | 统一对集合的访问方式           | 逐个检票进站 |                |
| 命令模式（Command Pattern）                   | 将请求封装成命令，并记录下来，能够撤销与重做                 | 运筹帷幄之中，决胜千里之外                                 | 解耦请求和处理                 | 遥控器       |                |
| 状态模式（State Pattern）                     | 根据不同的状态做出不同的行为                                 | 状态驱动行为，行为决定状态                                 | 绑定状态和行为                 | 订单状态跟踪 |                |
| 备忘录模式（Memento Pattern）                 | 保存对象的状态，在需要时进行恢复                             | 失足不成千古恨，想重来时就重来                             | 备份、后悔机制                 | 草稿箱       |                |
| 中介者模式（Mediator Pattern）                | 将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散 | 联系方式我给你，怎么搞定我不管                             | 统一管理网状资源               | 朋友圈       |                |
| 解释器模式（Interpreter Pattern）             | 给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子 | 我想说”方言“，一切解释权都归我                             | 实现特定语法解析               | 摩斯密码     |                |
| 观察者模式（Observer Pattern）                | 状态发生改变时通知观察者，一对多的关系                       | 到点就通知我                                               | 解耦观察者与被观察者           | 闹钟         |                |
| 访问者模式（Visitor Pattern）                 | 稳定数据结构，定义新的操作行为                               | 横看成岭侧成峰，远近高低各不同                             | 解耦数据结构和数据操作         | KPI考核      |                |
|                                               | 委派模式（Delegate Pattern）                                 | 允许对象组合实现与继承相同的代码重用，负责任务的调用和分配 | 这个需求很简单，怎么实现我不管 | 只对结果负责 | 授权委托书     |

### 防御使编程

##### 必要性

- 意外输入 
- 维护能力差

##### 定义

- 通过预见到（或至少预先推测到）问题所在，断 定代码中每个阶段可能出现的错误，并做出相应 的防范措施，来防止类似意外的发生
- 思想：
  - 子程序应该不因传入错误数据而被破坏，哪怕是由 其他子程序产生的错误数据 
  - 换句话说，要承认程序都会有问题，都会被修改

##### 区别

- 区别于检查错误 
  - –防御性编程并不能排除所有的程序错误 
- 区别于调试
  - 防御式编程是一种防卫方式，而不是补救方式
- 区别于测试
  - 测试不是防御式的，测试可以验证代码现在是 正确的，但不保证在经历修改之后不会出错

##### 技巧

- 使用好的编码风格和合理的设计 
- 不要仓促地编写代码 不要相信任何人 
- 编写清晰而非简洁的代码 
- 不让其他人做不该做的修补工作 
- 编译时打开所有警告开关 
- 检查所有的返回值 
- 在声明位置初始化所有变量 
- 尽可能推迟一些变量声明 
- 使用安全的数据结构 
- 使用标准语言工具 
- 审慎地进行强制转换

##### 处理非法数据

- 检查所有来源于外部的数据的值 –文件、用户、网络或其他外部接口 –确保在允许范围内
- 检查子程序所有输入参数的值 –∵数据来自于其他子程序

##### 什么时候使用断言

- 断言主要用于开发和维护阶段 –
  - 帮助查清相互矛盾的假定 –
  - 预料之外的情况 –
  - 传给子程序的错误数据等 –
- 生成产品代码时并不编译进去 
- –不希望用户看到产品代码中的断言信息 
- –同时避免降低系统性能
- 区别：
  - 用错误处理代码来处理预期会发生的非正常情况， 用断言来检查永远不该发生的情况 
  - –错误处理：检查有害的输入数据 –断言：检查代码中的bug，可看作是可执行的注解





# 期末

- 模式定义：反复出现的一般化的问题    MVC

- 模式针对一组约束条件：c护体会限制约束条件使得只有一组唯一解

- 需求对应模式

- 适配器模式：adapter 适配goose 使其可以quack

- 封装goose对象 调用背时陪着的方法完成

- `Quackable gooseDuck = new GooseAdapter(new Goose())`

  ### 装饰者

- 设计模式：装饰者模式：添加一个功能而不改变原来的类 （观察者模式不满足要求 抽象部分会影响主要功能集成

- 装饰者和被装饰者都有相同的接口

- 缺陷：难以控制装饰行为 simulator获得quackable对象时无法判断对象是否被装饰 时透明的 

- 可以将创建和装饰鸭子的行为封装在一起



- 绝大多数设计模式影响的是性能问题



### 组合模式

- 组合模式需要实现Complete所有的接口
- 透明组合不需要区分叶子节点和非叶子节点  叶子节点不用实现add remove
- 安全组合需要区分
- 组合模式永远和迭代器以供使用



- 对单个鸭子监听
- 责任链 终结者 观察者
- 中介者vs观察者
- 多对多vs一对多
- 一个观察者多个鸭子 ：观察者





- 需求needs demand requirement 
  - 系统更需要满足的目标
- 规约 statute
  - 系统的外部可观察到的行为
- 架构 architecture
  - 系统一级的组成部分
  - 各部分的交互方法
  - 使用的技术
- 设计 design
  - 如何完成任务
  - 需要写的代码
  - 专门关注OO设计





## 2019年期末

![image-20210626104326439](C:\Users\Administrator.DESKTOP-CGIO78B\AppData\Roaming\Typora\typora-user-images\image-20210626104326439.png)

![image-20210626104842207](C:\Users\Administrator.DESKTOP-CGIO78B\AppData\Roaming\Typora\typora-user-images\image-20210626104842207.png)

![image-20210626104853223](C:\Users\Administrator.DESKTOP-CGIO78B\AppData\Roaming\Typora\typora-user-images\image-20210626104853223.png)

![image-20210626104910212](C:\Users\Administrator.DESKTOP-CGIO78B\AppData\Roaming\Typora\typora-user-images\image-20210626104910212.png)p